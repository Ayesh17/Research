# -*- coding: utf-8 -*-
"""Copy of Copy of Research - VGG19 01

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_bI6S8MtPYqaQKgu9hOyDCypcrujgFC6
"""

import numpy as np
from tqdm import tqdm
import math
import os

import keras
from keras.models import *
from keras.layers import *
from keras.layers.core import Dense, Flatten
from keras.optimizers import Adam
from keras.metrics import categorical_crossentropy
from keras.preprocessing.image import ImageDataGenerator
from keras.layers.normalization import BatchNormalization
from keras.layers.convolutional import Conv2D
from sklearn.metrics import confusion_matrix
from keras.applications.densenet import DenseNet121
from keras.callbacks import *
from keras import backend as K
import itertools
import matplotlib.pyplot as plt
import cv2

from keras.utils import to_categorical
from sklearn.preprocessing import LabelBinarizer,LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix

from google.colab import drive
drive.mount('/content/drive')

covid_path = '/content/drive/My Drive/Research/Covid/'
covid_files = os.listdir(covid_path)

covid_labels = []
covid_data = []

for file in covid_files:
    imagePath = covid_path + file
    image = cv2.imread(imagePath)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (224, 224))
    covid_data.append(image)
    covid_labels.append('covid')

pneumonia_path = '/content/drive/My Drive/Research/Pneumonia/'
pneumonia_files = os.listdir(pneumonia_path)

pneumonia_labels = []
pneumonia_data = []

for file in pneumonia_files:
    imagePath = pneumonia_path + file
    image = cv2.imread(imagePath)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (224, 224))
    pneumonia_data.append(image)
    pneumonia_labels.append('pneumonia')

normal_path = '/content/drive/My Drive/Research/Normal/'
normal_files = os.listdir(normal_path)

normal_labels = []
normal_data = []

for file in normal_files:
    imagePath = normal_path + file
    image = cv2.imread(imagePath)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = cv2.resize(image, (224, 224))
    normal_data.append(image)
    normal_labels.append('normal')

data = covid_data + pneumonia_data + normal_data
 labels = covid_labels + pneumonia_labels + normal_labels

def step_decay(epoch):
    initial_lrate=0.001
    drop=0.1
    epochs_drop=10
    lrate=initial_lrate * math.pow(drop,math.floor((1+epoch)/epochs_drop))
    return lrate

lb = LabelEncoder()
labels = lb.fit_transform(labels)
labels = to_categorical(labels)
print(labels)

trainX, testX, trainY, testY = train_test_split(data, labels,
                                                  test_size=0.2, 
                                                  random_state=42)

trainX, valX, trainY, valY = train_test_split(trainX, trainY, test_size = 1/8)

lb.classes_

lb.inverse_transform([0,1,2])

lr=keras.callbacks.LearningRateScheduler(step_decay,verbose=1)


trainAug = ImageDataGenerator(rotation_range=2,
                              width_shift_range=0.2,
                              height_shift_range=0.2,
                              fill_mode="nearest")

len(trainX)

len(valX)

len(testX)

#### Downloading the Pre-trained Model
#mobnet_model = keras.applications.mobilenet.MobileNet()

baseModel = keras.applications.VGG19(weights="imagenet", 
                                     include_top= False,
                                     input_tensor=Input(shape=(224, 224, 3)))

baseModel.summary()

headModel = baseModel.output
headModel = AveragePooling2D(pool_size=(4, 4))(headModel)
headModel = Flatten(name="flatten")(headModel)
headModel = Dense(64, activation="relu")(headModel)
headModel = Dropout(0.4)(headModel)
headModel = Dense(3, activation="softmax")(headModel)
model = Model(inputs=baseModel.input, outputs=headModel)

for layer in baseModel.layers[:-2]:
    layer.trainable = False

lr_opt = 6e-4
epochs = 10
batch_size = 8

opt = Adam(lr=lr_opt, decay= lr_opt / epochs)


model.compile(loss="categorical_crossentropy", 
              optimizer=opt,
              metrics=["accuracy"])

model.summary()

lr=keras.callbacks.LearningRateScheduler(step_decay,verbose=1)

checkpoint= keras.callbacks.ModelCheckpoint('./Checkpoint_normal', monitor='val_acc', 
                                               verbose=0, save_best_only=True, 
                                               save_weights_only=False, 
                                               mode='auto',
                                               period=1)

print("[INFO] training head...")

history = model.fit_generator(
                trainAug.flow(np.array(trainX), np.array(trainY), batch_size=batch_size),
                steps_per_epoch=len(trainX) // batch_size,
                validation_data=(np.array(valX), np.array(valY),),
                validation_steps=len(valX) // batch_size,
                callbacks=[checkpoint,lr],
                epochs=20)

#Plotting
plt.figure()
plt.plot(np.arange(0, 20), history.history["loss"], label="train_loss")
plt.plot(np.arange(0, 20), history.history["val_loss"], label="val_loss")
plt.plot(np.arange(0, 20), history.history["accuracy"], label="train_acc")
plt.plot(np.arange(0, 20), history.history["val_accuracy"], label="val_acc")
plt.title("Plotting Loss and Accuracy on COVID-19 Image Dataset")
plt.xlabel("No of epochs")
plt.ylabel("Loss&Accyracy")
plt.legend(loc="lower left")
#plt.savefig(args["plot"])

predIdxs = model.predict(np.array(testX), batch_size=8)
predIdxs = np.argmax(predIdxs, axis=1)

predIdxs

testY.argmax(axis=1)

import sklearn
print(sklearn.metrics.confusion_matrix(testY.argmax(axis=1), predIdxs))

import seaborn as sns

#confution_matrix for tensorflow model
from sklearn.metrics import confusion_matrix
def plot_confution_matrix_heat_map(labels, predictions):
    cm = confusion_matrix(labels, predictions >0.5)
    plt.figure(figsize=(5,5))
    sns.heatmap(cm, annot=True, fmt="d",cmap=plt.cm.Blues)
    plt.title('Confusion matrix')

plot_confution_matrix_heat_map(testY.argmax(axis=1), predIdxs)

print(classification_report(testY.argmax(axis=1), predIdxs,target_names=['covid', 'normal', 'pneum']))



model.save("/kaggle/working/model_covid_vs_pneumonia_vs_normal.h5")

from keras.models import load_model
 
# load model
model = load_model('/kaggle/input/model-pneumonia-vs-covidh5/model_pneumonia_vs_covid.h5')

model.summary()

# img_path = norm_path + norm_files[0]
# norm_img = cv2.imread(img_path)
# norm_img = cv2.cvtColor(norm_img, cv2.COLOR_BGR2RGB)
# norm_img = cv2.resize(norm_img, (224, 224))
# norm_img = np.expand_dims(norm_img,axis=0)

def get_class_activation_map(ind,path,files) :
    
    img_path =  path + files[ind]
    img = cv2.imread(img_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img, (224, 224))
    img = np.expand_dims(img,axis=0)
    
    predict = model.predict(img)
    target_class = np.argmax(predict[0])
    last_conv = model.get_layer('block5_conv3')
    grads = K.gradients(model.output[:,target_class],last_conv.output)[0]
    pooled_grads = K.mean(grads,axis=(0,1,2))
    iterate = K.function([model.input],[pooled_grads,last_conv.output[0]])
    pooled_grads_value,conv_layer_output = iterate([img])
    
    for i in range(512):
        conv_layer_output[:,:,i] *= pooled_grads_value[i]
    
    heatmap = np.mean(conv_layer_output,axis=-1)
    
    for x in range(heatmap.shape[0]):
        for y in range(heatmap.shape[1]):
            heatmap[x,y] = np.max(heatmap[x,y],0)
    heatmap = np.maximum(heatmap,0)
    heatmap /= np.max(heatmap)
    plt.imshow(heatmap)
#     output_path_heatmap = '/kaggle/working/output_images/' + files[ind] + 'heatmap.jpeg'
#     plt.imsave(output_path_heatmap,heatmap)
    
    img_gray = cv2.cvtColor(img[0], cv2.COLOR_BGR2GRAY)
    upsample = cv2.resize(heatmap, (224,224))
    # plt.imshow(upsample,alpha=0.5)
    # plt.imshow(img_gray)
    #plt.imshow(upsample * img_gray)
    output_path_gradcam = '/kaggle/working/' + files[ind] + 'gradcam.jpeg'
    plt.imsave(output_path_gradcam,upsample * img_gray)
    
    #plt.show()
    
    #return img

path = pne_path
files = pne_files

get_class_activation_map(5,path,files)

path + files[5]

# import shutil
# shutil.rmtree('/kaggle/working/output_images/')
os.remo

np.arange(0,11)

# img_path = covid_path + covid_files[1]
# covid_img = cv2.imread(img_path)
# covid_img = cv2.cvtColor(covid_img, cv2.COLOR_BGR2RGB)
# covid_img = cv2.resize(covid_img, (224, 224))
# covid_img = np.expand_dims(covid_img,axis=0)

#norm_img.shape

#covid_img.shape

#predict = model.predict(norm_img)
# print(decode_predictions(predict,top=3))
# target_class = np.argmax(predict[0])

predict = model.predict(norm_img)

predict

# target_class = np.argmax(predict[0])
# target_class

#print("Target Class is covid")

#last_conv = model.get_layer('block5_conv3')

#grads = K.gradients(model.output[:,0],last_conv.output)[0]

# pooled_grads = K.mean(grads,axis=(0,1,2))
# iterate = K.function([model.input],[pooled_grads,last_conv.output[0]])
# pooled_grads_value,conv_layer_output = iterate([covid_img])

# for i in range(512):
#     conv_layer_output[:,:,i] *= pooled_grads_value[i]
# heatmap = np.mean(conv_layer_output,axis=-1)

# for x in range(heatmap.shape[0]):
#     for y in range(heatmap.shape[1]):
#         heatmap[x,y] = np.max(heatmap[x,y],0)

# heatmap = np.maximum(heatmap,0)
# heatmap /= np.max(heatmap)
# plt.imshow(heatmap)

#img_gray = cv2.cvtColor(norm_img[0], cv2.COLOR_BGR2GRAY)

upsample = cv2.resize(heatmap, (224,224))
# plt.imshow(upsample,alpha=0.5)
# plt.imshow(img_gray)
plt.imshow(upsample * img_gray)
plt.show()

upsample = cv2.resize(heatmap, (224,224))
# plt.imshow(upsample,alpha=0.5)
# plt.imshow(img_gray)
plt.imshow(upsample * img_gray)
plt.show()
